HW 4
Client_Server

2) Что такое HTTP и HTTPS
HTTP широко распространенный протокол передачи данных. HTTP- расшифровывается, как 
Hyper Text Transfer Protocol (протокол передачи гипертекста) Так же Http часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как: SOAB, XML-RPS, WebDAVю В таком случае говорят, что HTTP используется как транспорт.API многих программных продуктов так же подразумевает использование HTTP для передачи данных – сами данные при этом могут иметь любой формат например, XML, JSON. Как правило передача данных по протоколу HTTP осуществляется через TCP/IPсоединения. Серверное программное обеспечение при этом обычно использует TCP – порт 80, хотя может и другой.
     Сам по себе HTTP протокол не предполагает использование шифрования для передачи информации. Но есть для него расширение, которое реализует упаковку передаваемых данных в криптографический протокол SSL или TLS. Название расширения и есть HTTPS(Hyper Text Transfer Protocol Secure) Для HTTPS соединений обычно используется TCP –порт 443. На данный момент HTTPS поддерживается всеми популярными браузерами. HTTPS – это протокол который обеспечивает конфиденциальность обмена данными и пользовательским устройством. Безопасность информации обеспечивается за счет использования криптографических протоколов SSL/TLS, имеющих 3 уровня защиты:
    Шифрование данных позволяет избежать их перехвата;
    Сохранность данных – любое изменение данных фиксируется;
    Аутентификация защищает от перенаправления пользователя.
3) HTTP методы
HTTP – Протокол, который описывает взаимодействие между двумя компьютерами (клиентом и сервером) построенное на базе сообщений, называемых запрос и ответ (Request Response). Каждое сообщение состоит из трех частей: стартовая трока, заголовки и тело. При этом обязательной является только стартовая строка. Стартовые строки запроса и ответа имеют разный формат . Стартовая строка запроса выглядит так:
METHOD URI HTTP/ VERSION, где 
METHOD – это как раз метод HTTP запроса, URI – идентификатор ресурса, VERSION – версия протокола, на данный момент актуальна  версия 1.1)
Заголовки — это набор пар имя-значение, разделенных двоеточием. В заголовках передается различная служебная информация: кодировка сообщения, название и версия браузера, адрес, с которого пришел клиент (Referrer) и так далее.

Тело сообщения — это, собственно, передаваемые данные. В ответе передаваемыми данными, как правило, является html-страница, которую запросил браузер, а в запросе, например, в теле сообщения передается содержимое файлов, загружаемых на сервер. Но как правило, тело сообщения в запросе вообще отсутствует.

Пример HTTP-взаимодействия:
Запрос:
GET /index.php HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9b5) Gecko/2008050509 Firefox/3.0b5
Accept: text/html
Connection: close

Первая строка — это строка запроса, остальные — заголовки; тело сообщения отсутствует
Тип HTTP-запроса (также называемый HTTP-метод) указывает серверу на то, какое действие мы хотим произвести с ресурсом. Изначально (в начале 90-х) предполагалось, что клиент может хотеть от ресурса только одно — получить его, однако сейчас по протоколу HTTP можно создавать посты, редактировать профиль, удалять сообщения и многое другое. И эти действия сложно объединить термином «получение».

Для разграничения действий с ресурсами на уровне HTTP-методов и были придуманы следующие варианты:

    GET — получение ресурса
    POST — создание ресурса
    PUT — обновление ресурса (заменяет ресурс полностью)
    DELETE — удаление ресурса
    PATCH – редактирует ресурc
    HEAD - не получает body, только отправляет и получает HTTP-заголовки


Обратите внимание на тот факт, что спецификация HTTP не обязывает сервер понимать все методы (которых на самом деле гораздо больше, чем 4) — обязателен только GET, а также не указывает серверу, что он должен делать при получении запроса с тем или иным методом. А это значит, что сервер в ответ на запрос DELETE /index.php HTTP/1.1 не обязан удалять страницу index.php на сервере, так же как на запрос GET /index.php HTTP/1.1 не обязан возвращать вам страницу index.php, он может ее удалять, например

4) HTTP статус коды сервера
По группам

    100 — 199 Информационные
    200 — 299 Успешные
    300 — 399 Редиректы
    400 — 499 Клиентские ошибки
    500 — 599 Серверные ошибки

Популярные коды ответа

    Для редиректов SEO-шники рекомендуют 301 редиректы.
    401 не авторизован (юзер не представился)
    403 запрещено (юзер не уполномочен)
    404 ресурс не найден
    418 я чайник
    419 кука протухла (обычно ошибка проверки CSRF)
    502 Bad Gateway. Программа веб-сервер (Nginx) получила неправильный ответ от бэкенда (PHP). Скорее всего, что-то сломалось или неправильно настроено на сервере
    504 Gateway Timeout. Программа веб-сервер устала ждать ответа от бэкенда и отменила запрос к нему. Скорее всего, на бэкенде происходит что-то очень долгое, какое-то большое вычисление. Ну и все равно это не нормально, такого быть не должно.
    503 Maintenance Mode. На сервере ведутся технические работы.
Коды ответа, как и заголовки, можно посмотреть в браузере на вкладке Network или получить командой curl -I domain.ru. В отличие от заголовков, коды ответа бывают только в ответе и не используются в запросе.
5) Что такое ядро браузера 
Браузер = оболочка + ядро. Оболочка относится к оболочке браузера: например, меню, панели инструментов и т. д. Оно в основном предназначено для работы с пользовательским интерфейсом, настройки параметров и так далее. Оно вызывает ядро для реализации различных функций. Ядро - это ядро браузера. Ядро - это программа или модуль, который отображает контент на основе языка разметки.
Ядро браузера можно разделить на две части: движок рендеринга (инженер макета или движок рендеринга) и движок JS. Оно отвечает за получение содержимого веб-страницы (HTML, XML, изображения и т. д.) Организацию информации (например, добавление CSS и т. Д.) И расчет режима отображения веб-страницы, а затем вывод ее на монитор или принтер. Разные ядра браузера будут по-разному интерпретировать синтаксис веб-страницы, поэтому эффект рендеринга будет другим. Все веб-браузеры, почтовые клиенты и другие приложения, которым необходимо редактировать и отображать сетевой контент, требуют ядра. Движок JS анализирует язык Javascript и выполняет язык Javascript для достижения динамических эффектов веб-страницы.
(Wiki
)Браузерный движок (англ. layout engine) — представляет собой программу, преобразующую содержимое веб-страниц (файлы HTML, XML, цифровые изображения и т. д.) и информацию о форматировании (в форматах CSS, XSL и т. д.) в интерактивное изображение форматированного содержимого на экране. Браузерный движок обычно используется в веб-браузерах (отсюда название), почтовых клиентах и других программах, нуждающихся в отображении и редактировании содержимого веб-страниц.

6) Какие браузеры какиие ядра используют
Термин «браузерный движок» получил распространение после того, как движки стали «отделимыми» от браузера. В число наиболее распространённых движков входят следующие:

    Trident — проприетарный движок Microsoft Internet Explorer; используется многими программами для Microsoft Windows (например, мини-браузерами в программах Winamp и RealPlayer).
    Gecko — открытый движок проекта Mozilla; используется в большом числе программ, основанных на коде Mozilla (браузере Firefox, почтовом клиенте Thunderbird, наборе программ SeaMonkey).
    KHTML — разработан в рамках проекта KDE, используется в браузере Konqueror и послужил основой для WebKit.
    WebKit — движок для браузера Apple Safari, включенного в операционную систему Mac OS X, и браузера Google Chrome. Встроен в библиотеку Qt.
    Presto — проприетарный движок, разработанный Opera Software; является базой для браузера Opera, а также лицензирован для использования рядом сторонних компаний.	
Поддерживаемые

    Blink — движок браузера Chromium, браузера Google Chrome с 28 версии, Microsoft Edge с 79 версии, Opera c 15 версии и Vivaldi. Он является ответвлением WebKit.
    Gecko — открытый движок проекта Mozilla; используется в большом числе программ, основанных на коде Mozilla (браузере Firefox, почтовом клиенте Thunderbird, наборе программ SeaMonkey).
    WebKit — движок для браузера Apple Safari, включенного в операционную систему Mac OS X, и браузера Google Chrome (до 2013 года). Встроен в библиотеку Qt (Начиная с Qt 5.6 признан устаревшим).
    KHTML — разработан в рамках проекта KDE, используется в браузере Konqueror и послужил основой для WebKit.

(Разработкой собственного браузера занимается множество компаний: Google, Mozilla, Apple, Microsoft, Opera Software, Яндекс, Ростелеком, Vivaldi Technologies, много их…

Каждый добавляет какие-то свои "фишки", сервисы в создаваемый браузер. К примеру, Яндекс интегрирует свои сервисы, поиск.
С браузерными движками дела обстоят кардинально иначе. Вот список движков, их разработчиков и обладателей:
    Blink: Google
    Gecko: Mozilla
    WebKit: Apple
    EdgeHTML: Microsoft
Это основные обладатели и разработчики движков. В разработке им помогают сторонние компании на определенных условиях.
Например, рассмотрим самый популярный проект от компании Google — Chromium. Данный проект содержит в себе движок Blink. Создавать данный проект Google помогают такие компании как Intel, Facebook, IBM, LG Electronics, NVIDIA, Yandex. Полный список можно посмотреть тут.
Условия на которых компании помогают создавать Blink/Chromium описаны в разделе Legal stuff на сайте проекта Chromium. Если кратко, то всё что вы создаёте принадлежит (не эксклюзивно) Google.

Браузеры компаний Opera, Яндекс, Ростелеком и другие используют именно этот браузерный движок. Если быть до конца откровенным то заявления вроде "у нас есть свой браузер" не совсем правда. Собственные сервисы — да, а вот всё остальное принадлежит другой компании(ям). И эта другая компания предоставляет свой браузерный движок на определенных условиях.)

7) Что такое API
API (Application Programming Interface) — это код, который позволяет двум приложениям обмениваться данными с сервера. На русском языке его принято называть программным интерфейсом приложения. REST (Representational State Transfer) — это способ создания API с помощью протокола HTTP. На русском его называют «передачей состояния представления».
Технологию REST API применяют везде, где пользователю сайта или веб-приложения нужно предоставить данные с сервера. Например, при нажатии иконки с видео на видеохостинге REST API проводит операции и запускает ролик с сервера в браузере. В настоящее время это самый распространенный способ организации API. Он вытеснил ранее популярные способы SOAP и WSDL.

8. Что такое ендпоинты
https://vc.ru/dev/391965-kak-sozdat-endpointy-i-zachem-oni-nuzhny 
Конечные точки указывают, как получить доступ к ресурсу, а метод указывает разрешенные взаимодействия (такие как GET, POST или DELETE) с ресурсом.

Один и тот же ресурс обычно имеет множество связанных конечных точек, каждая из которых имеет разные пути и методы, но возвращает различную информацию об одном и том же ресурсе. Конечные точки обычно имеют краткие описания, похожие на общее описание ресурса, только еще короче. Кроме того, конечная точка показывает только конечный путь URL ресурса, а не базовый, общий для всех конечных точек, путь.

Примеры конечных точек :
Вот пример конечной точки ресурса User API Instagram
GET /users/self
GET /users/self/media/recent
RESPONSE:
https://api.instagram.com/v1/users/self/?access_token=ACCESS+TOKEN
Конечная точка обычно выделяется стилизованным образом для придания ей более визуального внимания. Большая часть документации строится вокруг конечной точки, поэтому, может, имеет смысл визуально выделить конечную точку в нашей документации.
Конечная точка, возможно, является наиболее важным аспектом документации API, потому что она является тем, что разработчики будут реализовывать для выполнения своих запросов
9) URL (URI, URL, URN)
URI – Унифицированный идентификатор ресурса
URI — последовательность символов, идентифицирующая физический или абстрактный ресурс, который не обязательно должен быть доступен через сеть Интернет, причем, тип ресурса, к которому будет получен доступ, определяется контекстом и/или механизмом.
Например:
    перейдя по http://example.com — мы попадем на http-сервер ресурса идентифицируемого как example.com
    в то же время ftp://example.com — приведет наc на ftp-сервер того же самого ресурса
    или например http://localhost/ — URI идентифицирующий саму машину откуда производится доступ
В современном интернете, чаще всего используется две разновидности URI — URL и URN.
Основное различие между ними — в задачах:
    URL — Uniform Resource Locator, помогает найти какой либо ресурс
    URN — Uniform Resource Name, помогает этот ресурс идентифицировать
Упрощая: URL — отвечает на вопрос: «Где и как найти что-то?», URN — отвечает на вопрос: «Как это что-то идентифицировать».

10) Идемпотентные HTTP методы
Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций. Корректно реализованные методы GET, HEAD, PUT и DELETE идемпотентны, но не метод POST. Также все безопасные методы являются идемпотентными.

Для идемпотентности нужно рассматривать только изменение фактического внутреннего состояния сервера, а возвращаемые запросами коды статуса могут отличаться: первый вызов DELETE вернёт код 200, в то время как последующие вызовы вернут код 404. Из идемпотентности DELETE неявно следует, что разработчики не должны использовать метод DELETE при реализации RESTful API с функциональностью удалить последнюю запись.
11) Безопасные HTTP методы
Некоторые HTTP-методы (например: HEAD, GET, OPTIONS и TRACE) определены как безопасные, это означает, что они предназначены только для получения информации и не должны изменять состояние сервера. Другими словами, они не должны иметь побочных эффектов, за исключением безобидных эффектов, таких как: логирование, кеширование, показ баннерной рекламы или увеличение веб-счетчика. Созданный произвольный GET-запрос, который не учитывает контекст состояния приложения, следует считать безопасным.

Упрощенно, безопасность означает, что вызов метода не имеет побочных эффектов. Следовательно, такие (безопасные) запросы клиенты могут безопасно совершать неоднократно, не опасаясь изменить состояние сервера. Это означает, что сервисы должны придерживаться определения безопасности для GET, HEAD, OPTIONS и TRACE операций. Не выполнения этого свойства может приводить в заблуждение потребителя сервиса, а также вызвать проблемы для веб-кеширования, поисковых систем и других автоматизированных агентов, которые непреднамеренно будут изменять состояние сервера.

По определению, безопасные операции идемпотентны, так как они приводят к одному и тому же результату на сервере.

Безопасные методы реализованы как операции только для чтения. Однако безопасность не означает, что сервер должен возвращать тот же самый результат каждый раз.
12) Иденфикация, Аутентификация, Авторизация
    Идентификация – процедура, в результате выполнения которой для субъекта выявляется его уникальный признак, однозначно определяющий его в информационной системе.
    Аутентификация – процедура проверки подлинности, например, проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.
    Авторизация – предоставление определенному лицу прав на выполнение определенных действий.
13) Что такое IP
P-адрес (от англ. Internet Protocol) — уникальный числовой идентификатор устройства в компьютерной сети, работающей по протоколу IP.
В сети Интернет требуется глобальная уникальность адреса; в случае работы в локальной сети требуется уникальность адреса в пределах сети. В версии протокола IPv4 IP-адрес имеет длину 4 байта, а в версии протокола IPv6 — 16 байт.
В 4-й версии IP-адрес представляет собой 32-битное число. Как правило, адрес записывается в виде четырёх десятичных чисел значением от 0 до 255 (эквиваленты четырём восьмибитным числам), разделённых точками, например, 192.168.0.3.
В 6-й версии IP-адрес является 128-битным. Как правило, адрес записывается в виде восьми четырёхзначных шестнадцатеричных чисел (эквивалентны восьми 16-битным числам), разделённых двоеточиями, например, 2001:0db8:85a3:0000:0000:8a2e:0370:7334. Ведущие нули допускается в записи опускать. Нулевые группы, идущие подряд, могут быть опущены, вместо них ставится двойное двоеточие (fe80:0:0:0:0:0:0:1 можно записать как fe80::1). Более одного такого пропуска в адресе не допускается.
IP-адрес состоит из двух частей: номера сети и номера узла.
Интернет-протокол работает так же, как и любой другой язык: передает информацию с использованием установленных правил. Устройства обнаруживают другие подключенные устройства и обмениваются с ними информацией, используя этот протокол. Проще говоря, все компьютеры, где бы они не находились, могут общаться друг с другом.

Использование IP-адресов обычно происходит незаметно. Процесс работает следующим образом:

    Устройство подключается к интернету не напрямую: сначала оно подключается к сети, подключенной к интернету, а сеть, в свою очередь, предоставляет устройству доступ к интернету.
    Если вы находитесь дома, скорее всего, этой сетью является сеть вашего интернет-провайдера. В офисе это будет сеть вашей компании.
    IP-адрес назначается устройству вашим интернет-провайдером.
    Ваша интернет-активность проходит через интернет-провайдера, а он перенаправляет вам ответы на запросы, используя ваш IP-адрес. Поскольку провайдер предоставляет доступ в Интернет, его роль заключается в назначении IP-адрес вашему устройству.
    Однако ваш IP-адрес может измениться, например, при включение или выключение модема или маршрутизатора. Можно также связаться с интернет-провайдером, чтобы он изменил IP-адрес.
    Если вы находитесь вне дома, например, путешествуете, и берете с собой устройство, домашний IP-адрес не закрепляется за устройством. Это связано с тем, что устройство будет использовать другую сеть (Wi-Fi в отеле, аэропорту, кафе) для доступа в интернет и другой временный IP-адрес, назначенный интернет-провайдером в отеле, аэропорту или кафе.


14) Что такое октеты в DNS
https://selectel.ru/blog/dns-server/ 
Прежде чем начать говорить о DNS-серверах, расскажем о самой технологии DNS (Domain Name System). DNS — это технология, которая позволяет браузеру вроде Firefox, Chrome или Edge найти запрошенный пользователем сайт по его имени.
Как работает DNS?
Принцип работы DNS похож на поиск и вызов контактов из телефонной книги смартфона. Ищем имя, нажимаем «позвонить», и телефон соединяет нас с нужным абонентом. Понятно, что смартфон в ходе звонка не использует само имя человека, вызов возможен только по номеру телефона. Если вы внесете имя без номера телефона, позвонить человеку не сможете.
Так и с сайтом. Каждому имени сайта соответствует набор цифр формата 000.000.000.000. Этот набор называется IP-адресом, примером реального IP-адреса является 192.168.0.154 или 203.113.89.134. Когда пользователь вводит в адресной строке браузера имя сайта, например google.com, компьютер запрашивает IP-адрес этого сайта на специальном DNS-сервере и после получения корректного ответа открывает сам сайт.
DNS-сервер -Это как раз и есть «книга контактов» интернета. DNS-сервер — это специализированный компьютер (или группа), который хранит IP-адреса сайтов. Последние, в свою очередь, привязаны к именам сайтов и обрабатывает запросы пользователя
Основное предназначение DNS-серверов — хранение информации о доменах и ее предоставление по запросу пользователей, а также кэширование DNS-записей других серверов. Это как раз «книга контактов», о которой мы писали выше.
NS используется для перевода человекочитаемых доменных имён (таких как example.com) в машиночитаемые IP-адреса (такие как 93.184.216.34). Для использования DNS нужно отправить запрос на DNS-сервер. Этот запрос содержит доменное имя, которое мы ищем. DNS-сервер пытается найти IP-адрес этого домена в своём внутреннем хранилище данных. Если находит, то возвращает его. Если не может найти, то перенаправляет запрос на другой DNS-сервер, и процесс повторяется до тех пор, пока IP-адрес не будет найден. Сообщения DNS обычно отправляются по протоколу UDP.
У всех сообщений DNS одинаковый формат:
+---------------------+
|       Заголовок     |
+---------------------+
|        Вопрос       | Вопрос для сервера имён
+---------------------+
|         Ответ       | Ресурсные записи (RR) с ответом на вопрос
+---------------------+
|       Authority     | Записи RR с указанием на уполномоченный сервер
+---------------------+
|     Дополнительно   | Записи RR с дополнительной информацией
Вопрос и ответ находятся в разных частях сообщения. В нашем запросе будут секции «Заголовок» и «Вопрос».
Header — Заголовок DNS пакета, состоящий из 12 октет.
D (16 бит) — данное поле используется как уникальный идентификатор транзакции. Указывает на то, что пакет принадлежит одной и той же сессии “запросов-ответов” и занимает 16 бит.

QR (1 бит) — данный бит служит для индентификации того, является ли пакет запросом (QR = 0) или ответом (QR = 1).

Opcode (4 бита) — с помощью данного кода клиент может указать тип запроса, где обычное значение:

    0 — стандартный запрос,
    1 — инверсный запрос,
    2 — запрос статуса сервера.
    3-15 – зарезервированы на будущее.

AA (1 бит) — данное поле имеет смысл только в DNS-ответах от сервера и сообщает о том, является ли ответ авторитетным либо нет.

TC (1 бит) — данный флаг устанавливается в пакете ответе в том случае если сервер не смог поместить всю необходимую информацию в пакет из-за существующих ограничений.

RD (1 бит) — этот однобитовый флаг устанавливается в запросе и копируется в ответ. Если он флаг устанавливается в запросе — это значит, что клиент просит сервер не сообщать ему промежуточных ответов, а вернуть только IP-адрес.

RA (1 бит) — отправляется только в ответах, и сообщает о том, что сервер поддерживает рекурсию

Z (3 бита) — являются зарезервированными и всегда равны нулю.

RCODE (4 бита) — это поле служит для уведомления клиентов о том, успешно ли выполнен запрос или с ошибкой.

    0 — значит запрос прошел без ошибок;
    1 — ошибка связана с тем, что сервер не смог понять форму запроса;
    2 — эта ошибка с некорректной работой сервера имен;
    3 — имя, которое разрешает клиент не существует в данном домене;
    4 — сервер не может выполнить запрос данного типа;
    5 — этот код означает, что сервер не может удовлетворить запроса клиента в силу административных ограничений безопасности.

QDCOUNT(16 бит) – количество записей в секции запросов
ANCOUNT(16 бит) – количество записей в секции ответы
NSCOUNT(16 бит) – количество записей в Authority Section
ARCOUNT(16 бит) – количество записей в Additional Record Section

15) Что такое порт, сколько портов у Linux сервера
Сетевой порт — идентифицируемый номером системный ресурс, выделяемый приложению, выполняемому на некотором сетевом хосте, для связи с приложениями, выполняемыми на других сетевых хостах (в том числе c другими приложениями на этом же хосте).

Для каждого из протоколов TCP и UDP стандарт определяет возможность одновременного выделения на хосте до 65536 уникальных портов, идентифицирующихся номерами от 0 до 65535. При передаче по сети номер порта в заголовке пакета используется (вместе с IP-адресом хоста) для адресации конкретного приложения (и конкретного, принадлежащего ему, сетевого соединения).

В обычной клиент-серверной модели приложение либо ожидает входящие данные (или запроса на соединение; «слушает порт»; роль сервера), либо посылает данные (или запрос на соединение) на известный порт, открытый приложением-сервером (роль клиента).

По умолчанию приложению выдается порт с произвольным (например, ближайшим свободным, большим 1023) номером. При необходимости приложение может запросить конкретный (предопределённый) номер порта. Так, веб-серверы обычно открывают для ожидания соединения предопределённый порт 80 протокола TCP.

Порты TCP не пересекаются с портами UDP. То есть, порт 1234 протокола TCP не будет мешать обмену по UDP через порт 1234.
Количество портов ограничено с учётом 16-битной адресации (216=65536, начало — «0»). Все порты разделены на три диапазона — общеизвестные (или системные, 0—1023), зарегистрированные (или пользовательские, 1024—49151) и динамические (или частные, 49152—65535).
По результатам тестирования можно доказать, что существуют ограничения на порты, произвольно выделяемые Linux. Теоретически количество внешних портов для одной машины может достигать 65535, но фактическое количество подключений, которые могут быть установлены с внешним миром, по умолчанию составляет только 28232. Вы можете увидеть, выполнив следующие команды под Linux:

    [root@bogon local]#  cat /proc/sys/net/ipv4/ip_local_port_range
    32768   60999

То есть можно использовать порты из этого диапазона, поэтому один IP-адрес может отправлять не более 28232 TCP-запросов извне.
https://russianblogs.com/article/94351091162/ 
16) Уровни OSI
Модель Open Systems Interconnection (OSI) – это скелет, фундамент и база всех сетевых сущностей. Модель определяет сетевые протоколы, распределяя их на 7 логических уровней. Важно отметить, что в любом процессе, управление сетевой передачей переходит от уровня к уровню, последовательно подключая протоколы на каждом из уровней.
1 уровень. Физический (physical). Единицей нагрузки (PDU) здесь является бит. Кроме единиц и нулей физический уровень не знает ничего. На этом уровне работают провода, патч панели, сетевые концентраторы (хабы, которые сейчас уже сложно найти в привычных нам сетях), сетевые адаптеры. Именно сетевые адаптеры и ничего более из компьютера. Сам сетевой адаптер принимает последовательность бит и передает её дальше.

2 уровень. Канальный (data link). PDU - кадр (frame). На этом уровне появляется адресация. Адресом является MAC адрес. Канальный уровень ответственен за доставку кадров адресату и их целостность. В привычных нам сетях на канальном уровне работает протокол ARP. Адресация второго уровня работает только в пределах одного сетевого сегмента и ничего не знает о маршрутизации - этим занимается вышестоящий уровень. Соответственно, устройства, работающие на L2 - коммутаторы, мосты и драйвер сетевого адаптера.

3 уровень. Сетевой (network). PDU пакет (packet). Наиболее распространенным протоколом (дальше не буду говорить про “наиболее распространенный” - статья для новичков и с экзотикой они, как правило,  не сталкиваются) тут является IP. Адресация происходит по IP-адресам, которые состоят из 32 битов. Протокол маршрутизируемый, то есть пакет способен попасть в любую часть сети через какое-то количество маршрутизаторов. На L3 работают маршрутизаторы.

4 уровень. Транспортный (transport). PDU сегмент (segment)/датаграмма (datagram). На этом уровне появляются понятия портов. Тут трудятся TCP и UDP. Протоколы этого уровня отвечают за прямую связь между приложениями и за надежность доставки информации. Например, TCP умеет запрашивать повтор передачи данных в случае, если данные приняты неверно или не все. Так же 
TCP может менять скорость передачи данных, если сторона приема не успевает принять всё (TCP Window Size).
Следующие уровни “правильно” реализованы лишь в RFC. На практике же, протоколы описанные на следующих уровнях работают одновременно на нескольких уровнях модели OSI, поэтому нет четкого разделения на сеансовый и представительский уровни. В связи с этим в настоящее время основным используемым стеком является TCP/IP, о котором поговорим чуть ниже.

5 уровень. Сеансовый (session). PDU данные (data). Управляет сеансом связи, обменом информации, правами. Протоколы - L2TP, PPTP.

6 уровень. Представительский (presentation). PDU данные (data). Преставление и шифрование данных. JPEG, ASCII, MPEG.

7 уровень. Прикладной (application). PDU данные (data). Самый многочисленный и разнообразный уровень. На нем выполняются все высокоуровненвые протоколы. Такие как POP, SMTP, RDP, HTTP и т.д. Протоколы здесь не должны задумываться о маршрутизации или гарантии доставки информации - этим занимаются нижестоящие уровни. На 7 уровне необходима лишь реализации конкретных действий, например получение html-кода или email-сообщения конкретному адресату.

17) Хедеры http запросов
Заголовки – это специальные параметры, которые несут определенную служебную информацию о соединении по HTTP. Некоторые заголовки имеют лишь информационный характер для пользователя или для компьютера, другие передают определенные команды, исходя из которых, сервер или клиент будет выполнять какие-то действия.
В зависимости от того, где эти заголовки могут находиться, они разделяются на:
General Headers (Основные заголовки) — должны быть и в запросах и в ответах клиента и сервера.
Request Headers (Заголовки запроса) — используются только в запросах клиента.
Response Headers (Заголовки ответа) — используются только в ответах сервера.
Entity Headers (Заголовки сущности) — сопровождают каждую сущность сообщения.
Каждый заголовок имеет следующий вид:
параметр: значение
Немного о правилах написания, что нужно иметь в виду:
1) Регистр (большие или маленькие буквы) здесь не учитываются. Можно писать и так и так.
2) Пишутся латинскими буквами.
3) После параметра должен идти символ двоеточия (:)
4) Окончанием пары «параметр:значение» служит символ переноса строки.Вот, примеры некоторых заголовков:
Host: webkyrs.info
User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:18.0) Gecko/20100101 Firefox/18.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3


